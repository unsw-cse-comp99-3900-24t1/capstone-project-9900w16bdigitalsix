TEST_CASE("Default predicate iterator test") {
    fsv::filtered_string_view fsv1{"corgi"};
    std::vector<char> result{fsv1.begin(), fsv1.end()};
    REQUIRE(result == std::vector<char>{'c', 'o', 'r', 'g', 'i'});
}

TEST_CASE("Custom predicate iterator test") {
    fsv::filtered_string_view fsv2{"samoyed", [](const char& c) {
        return !(c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u');
    }};
    auto it = fsv2.begin();
    REQUIRE(*it == 's');
    REQUIRE(*std::next(it) == 'm');
    REQUIRE(*std::next(it, 2) == 'y');
    REQUIRE(*std::next(it, 3) == 'd');
}

TEST_CASE("Reverse iterator test") {
    fsv::filtered_string_view fsv3{"milo", [](const char& c) {
        return !(c == 'i' || c == 'o');
    }};
    std::vector<char> result{fsv3.rbegin(), fsv3.rend()};
    REQUIRE(result == std::vector<char>{'l', 'm'});
}

TEST_CASE("Const iterator test") {
    const auto str = std::string("tosa");
    const fsv::filtered_string_view fsv4{str};
    auto it = fsv4.cend();
    REQUIRE(*std::prev(it) == 'a');
    REQUIRE(*std::prev(it, 2) == 's');
}

TEST_CASE("Range iteration test") {
    const auto str = std::string("puppy");
    const fsv::filtered_string_view fsv5{str, [](const char& c) {
        return !(c == 'u' || c == 'y');
    }};
    std::vector<char> result{fsv5.begin(), fsv5.end()};
    REQUIRE(result == std::vector<char>{'p', 'p', 'p'});
}

TEST_CASE("Reverse range iteration test") {
    const auto str = std::string("tosa");
    const fsv::filtered_string_view fsv6{str, [](const char& c) {
        return !(c == 'o' || c == 's');
    }};
    std::vector<char> result{fsv6.rbegin(), fsv6.rend()};
    REQUIRE(result == std::vector<char>{'a', 't'});
}

TEST_CASE("Iterator const correctness") {
    fsv::filtered_string_view fsv1{"corgi"};
    auto it = fsv1.begin();

    // 以下代码尝试修改元素，应该导致编译错误
    // *it = 'a';  // 编译错误：不能修改通过迭代器引用的元素

    // 验证迭代器返回的是 const char&
    REQUIRE(std::is_same_v<decltype(*it), const char&>);
}

TEST_CASE("Const iterator const correctness") {
    const auto str = std::string("tosa");
    const fsv::filtered_string_view fsv2{str};
    auto it = fsv2.cbegin();

    // 以下代码尝试修改元素，应该导致编译错误
    // *it = 'a';  // 编译错误：不能修改通过常量迭代器引用的元素

    // 验证常量迭代器返回的是 const char&
    REQUIRE(std::is_same_v<decltype(*it), const char&>);
}

TEST_CASE("Reverse iterator const correctness") {
    fsv::filtered_string_view fsv3{"milo"};
    auto it = fsv3.rbegin();

    // 以下代码尝试修改元素，应该导致编译错误
    // *it = 'a';  // 编译错误：不能修改通过反向迭代器引用的元素

    // 验证反向迭代器返回的是 const char&
    REQUIRE(std::is_same_v<decltype(*it), const char&>);
}

TEST_CASE("Const reverse iterator const correctness") {
    const auto str = std::string("tosa");
    const fsv::filtered_string_view fsv4{str};
    auto it = fsv4.crbegin();

    // 以下代码尝试修改元素，应该导致编译错误
    // *it = 'a';  // 编译错误：不能修改通过常量反向迭代器引用的元素

    // 验证常量反向迭代器返回的是 const char&
    REQUIRE(std::is_same_v<decltype(*it), const char&>);
}

